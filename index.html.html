<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Honeycomb Structure Simulation</title>
    
    

<script src="https://cdn.tailwindcss.com"></script>
    
    

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #111827; /* Dark gray */
            color: #f3f4f6; /* Light gray */
            overflow: hidden; /* Prevent page scrollbars */
        }
        
        /* The 3D canvas should be in the background */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1; /* Place it behind the UI panels */
        }

        /* Base style for UI panels */
        .ui-panel {
            position: absolute;
            background-color: rgba(31, 41, 55, 0.9); /* Semi-transparent dark bg */
            padding: 1.5rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 300px;
            z-index: 10;
            max-height: 90vh; /* Prevent panels from being too tall */
            overflow-y: auto; /* Allow panel to scroll if content is too long */
        }

        /* Control panel on the left */
        #controls-panel {
            top: 20px;
            left: 20px;
        }

        /* Analysis panel on the right */
        #analysis-panel {
            top: 20px;
            right: 20px;
            left: auto; /* FIX: Ensures it pins to the right */
        }

        #analysis-panel h3 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 700; /* font-bold */
            margin-bottom: 0.75rem; /* mb-3 */
            color: #fcd34d; /* amber-300 */
        }
        #analysis-panel h4 {
            font-semibold: 600;
            color: #fcd34d; /* amber-300 */
            margin-top: 0.75rem; /* mt-3 */
            margin-bottom: 0.25rem; /* mb-1 */
            font-size: 1.1rem;
        }
        #analysis-panel p {
            margin-bottom: 0.25rem; /* mb-1 */
            font-size: 0.875rem; /* text-sm */
            color: #d1d5db; /* gray-300 */
        }
        #analysis-panel .stat {
            font-weight: 600; /* font-semibold */
            color: #fff;
        }

        /* Style for the new select dropdown */
        select {
            width: 100%;
            background-color: #4b5563; /* gray-600 */
            color: #f3f4f6; /* gray-100 */
            border: 1px solid #6b7280; /* gray-500 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem; /* p-2 */
            margin-top: 0.25rem; /* mt-1 */
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='M7 7l3-3 3 3m0 6l-3 3-3-3'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.25em 1.25em;
        }
        
        /* Style for sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4b5563; /* gray-600 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fcd34d; /* amber-300 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fcd34d; /* amber-300 */
            border-radius: 50%;
            cursor: pointer;
        }

        /* Style for new checkboxes */
        input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            height: 1.25rem; /* h-5 */
            width: 1.25rem; /* w-5 */
            border-radius: 0.25rem; /* rounded */
            background-color: #4b5563; /* gray-600 */
            border: 1px solid #6b7280; /* gray-500 */
            color: #fcd34d; /* amber-400 */
            display: inline-block;
            vertical-align: middle;
            position: relative;
        }
        input[type="checkbox"]:checked {
            background-color: #fcd34d; /* amber-400 */
        }
        input[type="checkbox"]:checked::after {
            content: 'âœ”';
            font-size: 1rem;
            color: #111827; /* dark text */
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }


        /* Responsive layout for narrow screens */
        @media (max-width: 650px) {
            body {
                overflow-y: auto; /* Allow page to scroll on small screens */
            }
            .ui-panel {
                position: relative; /* Un-stick the panels */
                width: auto; /* Full width */
                left: 10px;
                right: 10px;
                top: 10px;
                margin-bottom: 10px;
            }
            #analysis-panel {
                top: 0; /* Remove top spacing */
            }
        }
    </style>
</head>
<body class="font-sans">

    

<div id="controls-panel" class="ui-panel">
        <h2 class="text-2xl font-bold mb-4 text-white">Structure Controls</h2>
        
        <div class="mb-4">
            <label for="shape-type" class="block text-sm font-medium text-gray-300">Structure Type</label>
            <select id="shape-type">
                <option value="hexagon" selected>Honeycomb (Hexagon)</option>
                <option value="square">Grid (Square)</option>
                <option value="triangle">Tessellation (Triangle)</option>
            </select>
        </div>

        <div class="mb-4">
            <label for="cell-height" class="block text-sm font-medium text-gray-300">Cell Height (Depth)</label>
            <div class="flex items-center space-x-2">
                <input type="range" id="cell-height" min="0.5" max="5" step="0.1" value="2" class="flex-1">
                <span id="cell-height-value" class="text-sm text-gray-100 w-10 text-right">2.0</span>
            </div>
        </div>

        <div class="mb-4">
            <label for="cell-area" class="block text-sm font-medium text-gray-300">Cell Area</label>
            <div class="flex items-center space-x-2">
                <input type="range" id="cell-area" min="1" max="10" step="0.5" value="5" class="flex-1">
                <span id="cell-area-value" class="text-sm text-gray-100 w-10 text-right">5.0</span>
            </div>
        </div>

        <div class="mb-4">
            <label for="rows" class="block text-sm font-medium text-gray-300">Rows (Vertical)</label>
            <div class="flex items-center space-x-2">
                <input type="range" id="rows" min="1" max="10" step="1" value="5" class="flex-1">
                <span id="rows-value" class="text-sm text-gray-100 w-10 text-right">5</span>
            </div>
        </div>

        <div class="mb-4">
            <label for="cols" class="block text-sm font-medium text-gray-300">Columns (Horizontal)</label>
            <div class="flex items-center space-x-2">
                <input type="range" id="cols" min="1" max="10" step="1" value="7" class="flex-1">
                <span id="cols-value" class="text-sm text-gray-100 w-10 text-right">7</span>
            </div>
        </div>
        
        <!-- NEW CONTROLS (HTML ADDED) -->
        <div class="flex justify-between items-center mt-4 mb-2">
            <label for="stagger-rows" class="text-sm font-medium text-gray-300">Stagger Rows</label>
            <input type="checkbox" id="stagger-rows" checked>
        </div>
        <div class="flex justify-between items-center">
            <label for="show-grid" class="text-sm font-medium text-gray-300">Show Floor Grid</label>
            <input type="checkbox" id="show-grid" checked>
        </div>
        
        <div class="mt-6">
            <button id="start-test-btn" class="w-full bg-amber-400 hover:bg-amber-500 text-gray-900 font-bold py-2 px-4 rounded-lg transition-colors duration-200">
                Start Compression Test
            </button>
        </div>

        <p class="text-xs text-gray-400 mt-6">Drag with mouse to rotate. Scroll to zoom.</p>
    </div>

    

<div id="analysis-panel" class="ui-panel">
        <h3>Efficiency Analysis (Strength-to-Weight)</h3>
        
        <div>
            <h4 class="font-semibold text-amber-300">Material Efficiency (Weight)</h4>
            <p>Shape: <span id="analysis-shape" class="stat">Hexagon</span></p>
            <p>Cell Area: <span id="analysis-area" class="stat">5.0</span></p>
            <p>Cell "Wax" (Perimeter): <span id="analysis-perimeter" class="stat">...</span></p>
            <p>Material Ratio: <span id="analysis-ratio" class="stat">...</span> <span class="text-xs">(Lower is better)</span></p>
        </div>

        <div>
            <h4 class="font-semibold text-amber-300">Structural Test (Strength)</h4>
            <p>Max Breaking Point: <span id="analysis-breaking-point" class="stat">...</span> kPa</p>
            <p>Live Applied Force: <span id="analysis-pressure" class="stat">0.0</span> kPa</p>
            <p>Structural Integrity: 
                <span id="analysis-integrity" class="stat text-lg font-bold text-green-400">100.0</span> %
            </p>
        </div>

        <div>
            <h4 class="font-semibold text-amber-300">Final Analysis</h4>
            <p>Strength-to-Weight Ratio: 
                <span id="analysis-sw-ratio" class="stat text-lg font-bold">...</span>
            </p>
            <p class="text-white">Live S-t-W Ratio: 
                <span id="analysis-live-ratio" class="stat text-lg font-bold">0.0</span>
            </p>

            

<h4 class="font-semibold text-amber-300 mt-4">Comparative Max Strength (kPa)</h4>
            <div class="space-y-2 text-xs">
                

<div class="flex items-center">
                    <span class="w-16">Hexagon</span>
                    <div class="flex-1 bg-gray-700 rounded-full h-4">
                        <div class="bg-amber-400 h-4 rounded-full" style="width: 100%" title="200 kPa"></div>
                    </div>
                    <span class="w-10 text-right font-bold">200</span>
                </div>
                

<div class="flex items-center">
                    <span class="w-16">Triangle</span>
                    <div class="flex-1 bg-gray-700 rounded-full h-4">
                        <div class="bg-green-400 h-4 rounded-full" style="width: 65%" title="130 kPa"></div>
                    </div>
                    <span class="w-10 text-right font-bold">130</span>
                </div>
                

<div class="flex items-center">
                    <span class="w-16">Square</span>
                    <div class="flex-1 bg-gray-700 rounded-full h-4">
                        <div class="bg-blue-400 h-4 rounded-full" style="width: 30%" title="60 kPa"></div>
                    </div>
                    <span class="w-10 text-right font-bold">60</span>
                </div>
            </div>
            
        </div>
    </div>


    <script type="module">
        // Global variables for the 3D scene
        let scene, camera, renderer, controls, honeycombGroup, gridHelper;
        let press, base; // For the hydraulic press
        let isTesting = false; // State for the animation
        let appliedPressure = 0; // Pressure value
        let breakingPoint = 0; // Shape's breaking point
        let cellRatio = 0; // For live calculation
        let currentShapeType = 'hexagon'; // To track current shape
        let structureTotalHeight = 0; // To calculate press target
        let crumblingCells = []; // Array to store cells that are falling

        // Re-using material for efficiency
        const hexMaterial = new THREE.MeshStandardMaterial({
            color: 0xfcb314, // Slightly darker amber
            metalness: 0.4,
            roughness: 0.3,
            emissive: 0x201505, // Darker self-illumination for outlines
            emissiveIntensity: 0.8
        });
        const sqMaterial = new THREE.MeshStandardMaterial({
            color: 0x3060d0, // Slightly darker blue
            metalness: 0.4,
            roughness: 0.3,
            emissive: 0x081030, // Darker self-illumination for outlines
            emissiveIntensity: 0.8
        });
        const triMaterial = new THREE.MeshStandardMaterial({
            color: 0x20c060, // Slightly darker green
            metalness: 0.4,
            roughness: 0.3,
            emissive: 0x052010, // Darker self-illumination for outlines
            emissiveIntensity: 0.8
        });
        // New polished metal for press/base
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc, // A light gray silver
            metalness: 0.9,
            roughness: 0.1,
        });

        // --- Core Functions ---

        /**
         * Initializes the entire 3D scene
         */
        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // Match body background
            scene.fog = new THREE.Fog(0x111827, 50, 100);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25); // Positioned to see the "wall"
            camera.lookAt(0, 0, 0);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows
            document.body.appendChild(renderer.domElement);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Spotlight for drama
            const spotLight = new THREE.SpotLight(0xffffff, 1.0, 100, Math.PI / 4, 0.5, 2);
            spotLight.position.set(0, 30, 20);
            spotLight.target.position.set(0, 0, 0);
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);
            scene.add(spotLight.target);

            // 5. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 60;
            controls.target.set(0, 0, 0);

            // 6. Honeycomb Group
            honeycombGroup = new THREE.Group();
            scene.add(honeycombGroup);

            // 7. Press, Base, and Grid
            createPress();
            
            // Grid helper
            gridHelper = new THREE.GridHelper(50, 20, 0x4b5563, 0x4b5563);
            gridHelper.position.y = -5; // Position it below the base
            gridHelper.rotation.x = Math.PI / 2; // Rotate to be a "back wall" if needed (or keep flat)
            scene.add(gridHelper);


            // 8. Event Listeners
            window.addEventListener('resize', onWindowResize);
            setupAllListeners();

            // 9. Initial Build & Animation
            generateStructure();
            animate();
        }

        /**
         * Creates the hydraulic press and base objects
         */
        function createPress() {
            const pressGeometry = new THREE.BoxGeometry(45, 2, 20); // Wide and deep
            
            // The top press
            press = new THREE.Mesh(pressGeometry, metalMaterial);
            press.position.set(0, 20, 0); // Start high up
            press.castShadow = true;
            scene.add(press);

            // The base
            base = new THREE.Mesh(pressGeometry, metalMaterial);
            base.position.set(0, -5, 0); // Below the grid
            base.receiveShadow = true; // Base will receive shadows
            scene.add(base);
        }

        /**
         * Resets the test animation and UI
         */
        function stopTest() {
            isTesting = false;
            appliedPressure = 0;
            
            // Reset press to high position
            press.position.y = 20; 

            // NEW: Reset group scale
            honeycombGroup.scale.set(1, 1, 1);

            // FIX: Clear any crumbling cells
            crumblingCells.forEach(cell => {
                scene.remove(cell.mesh); // Remove from scene
                cell.mesh.geometry.dispose(); // Clean up geometry
            });
            crumblingCells = []; // Empty the array

            // Reset UI
            document.getElementById('analysis-pressure').textContent = '0.0';
            document.getElementById('analysis-integrity').textContent = '100.0';
            document.getElementById('analysis-live-ratio').textContent = '0.0';
            updateIntegrityColor(100); // Reset color to green
            
            document.getElementById('start-test-btn').textContent = "Start Compression Test";
            document.getElementById('start-test-btn').disabled = false;

            // Re-enable controls
            document.querySelectorAll('#controls-panel input, #controls-panel select').forEach(el => el.disabled = false);
        }

        /**
         * Clears the old structure and generates a new one based on slider values
         */
        function generateStructure() {
            stopTest(); // Reset the test every time we regenerate

            // Clear previous structure
            honeycombGroup.traverse(child => {
                if (child.isMesh) {
                    child.geometry.dispose();
                }
            });
            honeycombGroup.clear();

            // Get values from controls
            const shapeType = document.getElementById('shape-type').value;
            currentShapeType = shapeType; 
            const cellHeight = parseFloat(document.getElementById('cell-height').value); // This is now DEPTH (Z-axis)
            const cellArea = parseFloat(document.getElementById('cell-area').value);
            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            const staggerRows = document.getElementById('stagger-rows').checked; // NEW
            const showGrid = document.getElementById('show-grid').checked; // NEW

            // Update value readouts
            document.getElementById('cell-height-value').textContent = cellHeight.toFixed(1);
            document.getElementById('cell-area-value').textContent = cellArea.toFixed(1);
            document.getElementById('rows-value').textContent = rows;
            document.getElementById('cols-value').textContent = cols;

            // --- Structure Grid Logic ---
            const internalGap = 0; // No gap for solid structure
            let geometry, material;
            let xStep, yStep, rowOffset = 0;
            let cellPerimeter, r;
            let totalWidth = 0, totalHeight = 0;
            
            // Re-calculate cellRatio for global scope
            cellRatio = 0;

            switch (shapeType) {
                case 'hexagon':
                    // A = (3 * sqrt(3) / 2) * r^2  => r = sqrt(2 * A / (3 * sqrt(3)))
                    r = Math.sqrt(2 * cellArea / (3 * Math.sqrt(3)));
                    // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)
                    // We set 'height' to cellHeight (which is our Z-depth)
                    geometry = new THREE.CylinderGeometry(r, r, cellHeight, 6);
                    material = hexMaterial;
                    
                    cellPerimeter = 6 * r;
                    breakingPoint = 200; // Strongest
                    
                    xStep = 1.5 * r + internalGap;
                    yStep = Math.sqrt(3) * r + internalGap;
                    rowOffset = xStep; // For staggered rows

                    totalWidth = (cols - 1) * xStep + (rows > 1 ? rowOffset : 0);
                    totalHeight = (rows - 1) * yStep;

                    document.getElementById('analysis-shape').textContent = "Hexagon";
                    break;

                case 'square':
                    // A = s^2 => s = sqrt(A)
                    const s = Math.sqrt(cellArea); // s is side length
                    geometry = new THREE.BoxGeometry(s, s, cellHeight);
                    material = sqMaterial;

                    cellPerimeter = 4 * s;
                    breakingPoint = 60; // Weakest
 
                    xStep = s + internalGap;
                    yStep = s + internalGap;
                    rowOffset = xStep / 2; // Stagger like bricks

                    totalWidth = (cols - 1) * xStep + (rows > 1 ? rowOffset : 0);
                    totalHeight = (rows - 1) * yStep;

                    document.getElementById('analysis-shape').textContent = "Square";
                    break;

                case 'triangle':
                    // A = (s^2 * sqrt(3)) / 4 => s = sqrt(4 * A / sqrt(3))
                    const sTri = Math.sqrt(4 * cellArea / Math.sqrt(3));
                    r = sTri / Math.sqrt(3); // 'r' is circumradius
                    geometry = new THREE.CylinderGeometry(r, r, cellHeight, 3);
                    material = triMaterial;

                    cellPerimeter = 3 * sTri;
                    breakingPoint = 130; // Medium
 
                    xStep = sTri + internalGap;
                    yStep = (sTri * Math.sqrt(3) / 2) + internalGap; // Height of an equilateral triangle
                    rowOffset = xStep / 2;

                    totalWidth = (cols - 1) * xStep + (rows > 1 ? rowOffset : 0);
                    totalHeight = (rows - 1) * yStep;

                    document.getElementById('analysis-shape').textContent = "Triangle";
                    break;
            }

            // Calculate and display efficiency ratio
            cellRatio = cellPerimeter / cellArea; // Set global variable
            document.getElementById('analysis-area').textContent = cellArea.toFixed(2);
            document.getElementById('analysis-perimeter').textContent = cellPerimeter.toFixed(3);
            document.getElementById('analysis-ratio').textContent = cellRatio.toFixed(4);
            document.getElementById('analysis-breaking-point').textContent = breakingPoint.toFixed(0);
            document.getElementById('analysis-sw-ratio').textContent = (breakingPoint / cellRatio).toFixed(2);


            // Create the grid of shapes (vertical wall on XY plane)
            for (let r_grid = 0; r_grid < rows; r_grid++) {
                for (let c_grid = 0; c_grid < cols; c_grid++) {
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    let x = c_grid * xStep;
                    let y = r_grid * yStep;
                    
                    // Apply row offset for staggered pattern
                    if (staggerRows && r_grid % 2 !== 0) { // MODIFIED
                        x += rowOffset;
                    }
                    
                    mesh.position.set(x, y, 0); // Position on XY plane
                    mesh.rotation.x = Math.PI / 2; // Rotate to face camera
                    
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { initialY: y }; // Store initial Y for reset

                    honeycombGroup.add(mesh);
                }
            }

            // --- Center the Grid ---
            structureTotalHeight = totalHeight; // Store for press calculation
            honeycombGroup.position.x = -totalWidth / 2;
            honeycombGroup.position.y = -totalHeight / 2; // Center vertically
            
            // Adjust base and grid helper to sit just below the structure
            const structureBottom = honeycombGroup.position.y;
            base.position.y = structureBottom - 3; // Increased gap to 3 units
            
            gridHelper.visible = showGrid; // NEW
            
            gridHelper.position.y = base.position.y - 1.1; // Place grid just below base
            gridHelper.rotation.x = 0; // Make grid flat on XZ plane
 
            // Adjust controls target
            controls.target.set(0, 0, 0);
            controls.update();
        }

        /**
         * Simulates the structure crumbling under pressure
         */
        function crumbleStructure() {
            const baseTop = base.position.y + 1; // Top of the base plate

            honeycombGroup.children.forEach(mesh => {
                scene.attach(mesh); // Remove from group, add to scene
                crumblingCells.push({
                    mesh: mesh,
                    velocity: new THREE.Vector3( (Math.random() - 0.5) * 0.1, 0, (Math.random() - 0.5) * 0.1 ),
                    angularVelocity: new THREE.Vector3( (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1 ),
                    baseY: baseTop + (mesh.geometry.parameters.height / 2) // Stop just on top of the base
                });
            });
            honeycombGroup.clear(); // Empty the group
        }

        /**
         * Starts the compression test
         */
        function startTest() {
            if (isTesting) return; // Already running

            if (document.getElementById('start-test-btn').textContent === "Reset Simulation") {
                generateStructure(); // This will stopTest() and redraw.
                return;
            }

            isTesting = true;
            appliedPressure = 0;
            const structureTop = structureTotalHeight + honeycombGroup.position.y;
            press.position.y = structureTop + 2; // Start just above structure
            
            // Disable controls
            document.getElementById('start-test-btn').textContent = "TEST IN PROGRESS...";
            document.getElementById('start-test-btn').disabled = true;
            document.querySelectorAll('#controls-panel input, #controls-panel select').forEach(el => el.disabled = true);
        }

        /**
         * Sets up event listeners for all UI elements
         */
        function setupAllListeners() { 
            const controls = document.querySelectorAll('#controls-panel input[type="range"], #controls-panel select, #controls-panel input[type="checkbox"]'); // MODIFIED
            controls.forEach(control => {
                // 'input' for sliders, 'change' for select/checkbox
                const eventType = (control.type === 'range') ? 'input' : 'change'; // MODIFIED
                
                // Add listener, but special-case the grid toggle
                if (control.id !== 'show-grid') { // MODIFIED
                    control.addEventListener(eventType, generateStructure);
                }
            });

            const testBtn = document.getElementById('start-test-btn');
            testBtn.addEventListener('click', startTest);

            // NEW LISTENER for grid visibility
            document.getElementById('show-grid').addEventListener('change', (e) => {
                gridHelper.visible = e.target.checked;
            });
        }
        
        /**
         * Updates the color of the integrity text based on its value
         */
        function updateIntegrityColor(integrity) {
            const integrityEl = document.getElementById('analysis-integrity');
            if (!integrityEl) return; // Guard clause

            let colorClass = 'text-green-400'; // Default
            if (integrity < 75) {
                colorClass = 'text-yellow-400';
            }
            if (integrity < 30) {
                colorClass = 'text-red-500';
            }
            // Note: We set the full class list to ensure old colors are removed
            integrityEl.className = `stat text-lg font-bold ${colorClass}`;
        }


        /**
         * The animation loop that renders the scene every frame
         */
        function animate() {
            requestAnimationFrame(animate); // Loop
            
            controls.update(); // Update controls (for damping)

            // Compression Test Animation Logic
            if (isTesting) {
                const pressSpeed = 0.001; // Current speed
                const structureTop = structureTotalHeight + honeycombGroup.position.y;
                const targetY = structureTop + 1; // Press stops 1 unit above (on top of) structure

                if (press.position.y > targetY) {
                    press.position.y -= pressSpeed;
                    
                    // Map press position to pressure
                    const startY = structureTop + 2;
                    const pressTravel = startY - targetY;
                    const currentTravel = startY - press.position.y;
                    appliedPressure = (currentTravel / pressTravel) * breakingPoint;
                    
                    // NEW: Apply bending/squashing effect
                    const scalePercent = appliedPressure / breakingPoint;
                    honeycombGroup.scale.y = 1.0 - (scalePercent * 0.1); // Squash by up to 10%
                    honeycombGroup.scale.x = 1.0 + (scalePercent * 0.05); // Bulge by up to 5%

                    
                    if (appliedPressure >= breakingPoint) {
                        // FAILURE!
                        appliedPressure = breakingPoint;
                        isTesting = false;
                        document.getElementById('start-test-btn').textContent = "Reset Simulation";
                        document.getElementById('start-test-btn').disabled = false;
                        
                        // NEW: Reset scale just before crumbling to avoid scaled pieces
                        honeycombGroup.scale.set(1, 1, 1); 

                        crumbleStructure();
                    }

                } else {
                    // This case should no longer be hit if all structures break
                    isTesting = false; 
                    press.position.y = targetY; // Clamp position
                    document.getElementById('start-test-btn').textContent = "Reset Simulation";
                    document.getElementById('start-test-btn').disabled = false;
                }
                
                // Update UI readout
                const integrity = Math.max(0, (1 - (appliedPressure / breakingPoint)) * 100);
                document.getElementById('analysis-pressure').textContent = appliedPressure.toFixed(1);
                document.getElementById('analysis-integrity').textContent = integrity.toFixed(1);
                updateIntegrityColor(integrity); // Call the new function
                
                const liveRatio = (appliedPressure / cellRatio).toFixed(2);
                document.getElementById('analysis-live-ratio').textContent = liveRatio;
            }

            // Update crumbling cells (simple physics with collision)
            const gravity = -0.01;
            crumblingCells.forEach(cell => {
                if (cell.mesh.position.y > cell.baseY) {
                    cell.velocity.y += gravity; // Apply gravity
                    cell.mesh.position.add(cell.velocity); // Update position
                    
                    // Apply angular velocity
                    cell.mesh.rotation.x += cell.angularVelocity.x; 
                    cell.mesh.rotation.y += cell.angularVelocity.y;
                    cell.mesh.rotation.z += cell.angularVelocity.z;
                } else {
                    // Hit the ground
                    cell.mesh.position.y = cell.baseY; // Stop at base
                    cell.velocity.y = 0; // Stop falling
                    cell.angularVelocity.x *= 0.9; // Dampen rotation
                    cell.angularVelocity.y *= 0.9;
                    cell.angularVelocity.z *= 0.9;
                }
            });
            
            renderer.render(scene, camera); // Render the scene
        }

        /**
         * Handles window resize events to keep the canvas responsive
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start the application ---
        init();

    </script>
</body>
</html>

